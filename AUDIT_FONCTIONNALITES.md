# Audit des fonctions et recommandations

## Fonctions prioritaires Ã  amÃ©liorer

1. **`Detection::detect_post_linked_images`** â€“ La dÃ©tection repose sur une analyse rÃ©cursive des blocs suivie d'une expression rÃ©guliÃ¨re gÃ©nÃ©rique sur le HTML brut. Cela reste fragile face aux attributs modernes (`data-src`, `loading="lazy"`, `<figure>` complexes) et ne tient pas compte des mÃ©dias chargÃ©s dynamiquement. Les solutions professionnelles s'appuient sur des parseurs DOM tolÃ©rants, des heuristiques spÃ©cifiques par bloc et un cache diffÃ©renciÃ© (par post type, par langue) pour rÃ©duire les faux positifs et accÃ©lÃ©rer les rÃ©ponses.ã€F:ma-galerie-automatique/includes/Content/Detection.phpâ€ L142-L200ã€‘

2. **`Detection::blocks_contain_linked_media`** â€“ L'algorithme suit les blocs rÃ©utilisables via un cache statique, mais il rÃ©alise des appels `get_post()` synchrones et ne diffÃ©rencie pas les blocs dynamiques (Query Loop, galeries distantes). Les produits Â« pro Â» prÃ©chargent les rÃ©fÃ©rences via `rest_do_request`, mÃ©morisent les IDs visitÃ©s par requÃªte et appliquent une stratÃ©gie de timeout ou de files d'attente pour Ã©viter les cascades rÃ©cursives coÃ»teuses lorsque le contenu comporte de nombreuses rÃ©fÃ©rences croisÃ©es.ã€F:ma-galerie-automatique/includes/Content/Detection.phpâ€ L247-L305ã€‘

3. **`Translation\Manager::load_textdomain`** â€“ Le fallback base64 est dÃ©sormais encapsulÃ© dans un gestionnaire dÃ©diÃ© qui dÃ©code le `.mo` une fois vers `wp-content/uploads/mga-translations/` et respecte les bascules de locale sans multiplier les I/O. Prochaine Ã©tapeÂ : brancher `WP_Filesystem` et un cache distribuÃ© pour les environnements sans accÃ¨s disque direct (App Engine, Lambda).ã€F:ma-galerie-automatique/includes/Translation/Manager.phpâ€ L9-L108ã€‘

4. **`Frontend\Assets::enqueue_assets`** â€“ Le chargement des assets injecte systÃ©matiquement Swiper et les styles associÃ©s, sans diffÃ©rencier les vues ni proposer de dÃ©coupage conditionnel (par exemple dÃ©sactiver les miniatures ou le module de partage). Les solutions pro dÃ©coupent les bundles (ES modules, CSS critiques), ajoutent des prÃ©chargements (`wp_enqueue_scripts` + `wp_resource_hints`) et gÃ¨rent les dÃ©pendances via `wp_register_*` pour permettre aux thÃ¨mes de substituer facilement les ressources.ã€F:ma-galerie-automatique/includes/Frontend/Assets.phpâ€ L23-L177ã€‘

5. **`Plugin::register_block` / `prepare_block_settings`** â€“ Le bloc Ã©diteur expose uniquement un script dâ€™aperÃ§u mais aucun `view_script`, `render_callback` ou gestion dynamique des attributs. Les Ã©diteurs avancÃ©s alignent les options du bloc sur les rÃ©glages front (synchronisation par REST, prÃ©visualisation SSR) et valident les couleurs/typographies cÃ´tÃ© serveur afin dâ€™Ã©viter les divergences de rendu entre Ã©diteur et front.ã€F:ma-galerie-automatique/includes/Plugin.phpâ€ L157-L244ã€‘

6. **`Plugin::maybe_purge_detection_cache`** â€“ La purge invalide lâ€™ensemble du cache dÃ¨s quâ€™un paramÃ¨tre de dÃ©tection varie. Des solutions plus fines segmentent par type de contenu ou par site multilingue, et enregistrent des journaux dâ€™invalidation pour aider au diagnostic lors dâ€™un pic de recalcul.ã€F:ma-galerie-automatique/includes/Plugin.phpâ€ L246-L335ã€‘

7. **`Settings::handle_switch_blog`** â€“ La couverture unitaire vÃ©rifie dÃ©sormais lâ€™invalidation du cache, mais il reste Ã  implÃ©menter un cache diffÃ©renciÃ© par rÃ©seau (objet-cache) pour absorber les fortes volumÃ©tries multisites sans recalculs rÃ©pÃ©tÃ©s.ã€F:tests/phpunit/SettingsCacheTest.phpâ€ L52-L91ã€‘

8. **`Frontend\Assets::refresh_swiper_asset_sources`** â€“ Le rafraÃ®chissement consigne maintenant le contexte via `mga_swiper_asset_sources_refreshed`, mais lâ€™option reste mono-site et sans TTL par rÃ©seau. Un stockage modulaire (site option + instrumentation) faciliterait les diagnostics CDN/local et la personnalisation par thÃ¨me.ã€F:ma-galerie-automatique/includes/Frontend/Assets.phpâ€ L395-L418ã€‘

### Feuille de route technique dÃ©taillÃ©e

| Fonction | Semaine cible | Ã‰tapes recommandÃ©es | Tests Ã  prÃ©voir | Indicateurs | Risques / mitigation |
| --- | --- | --- | --- | --- | --- |
| `Detection::detect_post_linked_images` | Semaine 1-3 | â€¢ Introduire un parseur DOM (`HTML5DOMDocument`) et une couche dâ€™abstraction des sÃ©lecteurs.<br>â€¢ Ajouter un cache transitoire basÃ© sur (post ID, langue, hash rÃ©glages).<br>â€¢ Isoler les heuristiques par bloc dans des classes dÃ©diÃ©es pour prÃ©parer les extensions tierces. | â€¢ Tests PHPUnit couvrant les blocs `core/gallery`, `core/image`, Query Loop.<br>â€¢ Tests E2E Playwright pour galeries mixtes (image + vidÃ©o). | â€¢ Temps moyen de dÃ©tection sur 100 articles.<br>â€¢ Nombre de faux positifs remontÃ©s via debug mode. | â€¢ RÃ©gression sur blocs tiers â†’ prÃ©voir un mode rÃ©trocompatibilitÃ© activable via filtre. |
| `Detection::blocks_contain_linked_media` | Semaine 2-4 | â€¢ Mettre en place un prÃ©chargement des blocs rÃ©utilisables (`REST API`).<br>â€¢ Introduire une liste de blocs dynamiques connus et un timeout pour Ã©viter les boucles.<br>â€¢ Exposer un hook pour enregistrer des stratÃ©gies custom. | â€¢ Tests unitaires simulant des boucles imbriquÃ©es.<br>â€¢ Tests de performance sur pages avec 10+ blocs rÃ©utilisables. | â€¢ Nombre de requÃªtes `get_post()`.<br>â€¢ Temps maximal de parcours des blocs. | â€¢ Risque de surcharge REST â†’ limiter les batchs et journaliser les erreurs. |
| `Plugin::load_textdomain` | Semaine 3-4 | â€¢ Externaliser la logique dans `TranslationManager`.<br>â€¢ Supporter `switch_locale` et multisite via caches segmentÃ©s.<br>â€¢ Mettre en place une migration pour supprimer le fallback base64 Ã  terme. | â€¢ Tests PHPUnit `switch_to_locale`.<br>â€¢ Test manuel multisite + plugin de traduction. | â€¢ Temps de chargement du textdomain.<br>â€¢ Nombre dâ€™E/S disque par requÃªte. | â€¢ Perte de traductions custom â†’ documenter un guide de migration + hook de fallback. |
| `Frontend\\Assets::enqueue_assets` | Semaine 4-6 | â€¢ Enregistrer chaque fonctionnalitÃ© (`core`, `thumbs`, `share`, `debug`) via `wp_register_*`.<br>â€¢ Ajouter un mÃ©canisme de chargement conditionnel + lazy-loading.<br>â€¢ Documenter un guide de surcharge thÃ¨me. | â€¢ Tests PHPUnit (simulation WordPress enqueue).<br>â€¢ Audit Lighthouse/WebPageTest avant/aprÃ¨s. | â€¢ Poids total bundle.<br>â€¢ Score performance Lighthouse. | â€¢ CompatibilitÃ© thÃ¨me â†’ prÃ©voir un filtre de repli pour charger lâ€™ancien bundle. |
| `Plugin::register_block` & `prepare_block_settings` | Semaine 5-7 | â€¢ DÃ©finir `block.json` complet (`viewScript`, `editorScript`, `render`).<br>â€¢ CrÃ©er un endpoint REST de synchronisation des rÃ©glages.<br>â€¢ Ajouter un composant React dâ€™aperÃ§u live et presets. | â€¢ Tests Jest sur le store.<br>â€¢ Tests Playwright dans Gutenberg (changement rÃ©glages). | â€¢ Satisfaction des bÃªta testeurs Ã©diteurs.<br>â€¢ Alignement visuel admin/front. | â€¢ MontÃ©e en charge JS â†’ surveiller le bundle final et lazy-load dans Gutenberg. |
| `Plugin::maybe_purge_detection_cache` | Semaine 6-8 | â€¢ Introduire un scheduler diffÃ©rÃ© pour purges massives.<br>â€¢ Segmenter les metas (`_mga_cache_{lang}_{post_type}`).<br>â€¢ Logguer les purges (CPT ou Action Scheduler) et exposer un Ã©cran dâ€™historique. | â€¢ Tests PHPUnit couvrant purges diffÃ©rÃ©es et par segment.<br>â€¢ Test E2E sur modification dâ€™option critique. | â€¢ Temps de purge.<br>â€¢ Nombre dâ€™Ã©vÃ©nements logguÃ©s. | â€¢ Accumulation de jobs â†’ prÃ©voir un mÃ©canisme de throttle et dâ€™alerte. |

## Tests de dÃ©bogage recommandÃ©s

- **`DetectionSettingsPurgeTest::test_detection_setting_change_purges_cache`** : vÃ©rifie que la modification des types suivis supprime bien le meta `_mga_has_linked_images`. Permet de confirmer que les purges sâ€™exÃ©cutent lors des changements critiques.ã€F:tests/phpunit/DetectionSettingsPurgeTest.phpâ€ L12-L40ã€‘
- **`DetectionSettingsPurgeTest::test_unrelated_setting_change_preserves_cache`** : garantit quâ€™un rÃ©glage hors pÃ©rimÃ¨tre (ex. `debug_mode`) ne vide pas inutilement le cache, ce qui aide Ã  diagnostiquer les invalidations intempestives.ã€F:tests/phpunit/DetectionSettingsPurgeTest.phpâ€ L42-L67ã€‘
- **`DetectionSettingsPurgeTest::test_normalized_selector_equivalence_does_not_trigger_purge`** : assure que les variations de casse/espaces des sÃ©lecteurs ne provoquent pas de purge, utile pour isoler les divergences entre interface admin et base de donnÃ©es.ã€F:tests/phpunit/DetectionSettingsPurgeTest.phpâ€ L69-L97ã€‘
- **Couverture multisite**Â : `SettingsCacheTest::test_handle_switch_blog_invalidates_cache_snapshot` garantit dÃ©sormais lâ€™invalidation aprÃ¨s `switch_blog`; planifiez nÃ©anmoins des scÃ©narios avec objet-cache distribuÃ© pour surveiller les performances en rÃ©seau volumineux.ã€F:tests/phpunit/SettingsCacheTest.phpâ€ L52-L91ã€‘

> ğŸ’¡ ComplÃ©tez ces tests PHP par une vÃ©rification E2E sur une page de dÃ©monstration (mode debug actif) afin de capturer les rÃ©gressions de performance lors des purges massives.
